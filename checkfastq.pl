#!/usr/bin/perl

use strict;
use warnings;
use Data::Dumper;
use Getopt::Long;
use feature qw(say);

#############################################################
my $USAGE = <<USAGE;
Script to filter contigs assembled from paired-end Illumina reads
by quality in non-overlapping regions of reads.

This script is designed to be used in combination with mothur metagenomic package after 
running command make.contigs. The latter command finds the overlapping parts
of reads and assembles them into a contig taking quality of the reads into consideration.

However, no quality filtering is peformed within non-overlapping parts of reads.
Given the error rates corellate with low-quality positions, evaluation of 
a portion of contigs to be discarded due to low Phred values in 1x contig parts
as well as filtering out such contigs migth be desirable.

Usage: checkfastq.pl -f R1.fastq -r R2.fastq -c CONTIGS -s REPORT [OPTIONS]
Options:
	-f, -r	[str]	files with R1 and R2 Illumina reads (Illumina 1.8+ format)
	
	-c	[str]	file with contigs
	-s	[str]	file with assembly statistics
			these two files are generated by make.contigs command in mothur
			
	-qual	[int]	minimal Phred-quality value whitin non-overlapping contig region
			to discard contig [default=20]
	-maxpos	[int]	maximum number of positions below the quality threshold 
			allowed for both R1 and R2 [default=0]
	-write	[0:1]	discard contigs having Phred-values lower the threshold 
			and write the filtered contigs into STDOUT. If zero, prints
			the distribution of low-quality positions and filtered contigs.
			[default=0]
	-help|?		get this message

USAGE
#############################################################
my %opts = (
	qual	=> 20,
	write	=> 0,
	maxpos	=> 0
);

GetOptions (
	\%opts,
	'f=s',
	'r=s',
	'c=s',
	's=s',
	'qual=i',
	'maxpos=i',
	'write',
	'help|?'
) || die($USAGE);

die($USAGE) if $opts{help};

open(F,"<$opts{f}") || die("Cannot open input file: $!");
open(R,"<$opts{r}") || die("Cannot open input file: $!");
open(C,"<$opts{c}") || die("Cannot open input file: $!");
open(S,"<$opts{s}") || die("Cannot open input file: $!");

my %c;
while (<S>) {
	next if /^name/i;
	chomp;
	my @a = split;
	$c{$a[0]} = [ @a[2..4] ];
}

while ( (my @a = map $_ = <C>, 1 .. 2)[0]) {
	@a = map { s/[\s\t\n]+//g; $_ } @a;
	$a[0] = substr($a[0], 1);
	$c{$a[0]}[3] = $a[1];
}

my (@stat, @oc);
while ( (my @f = map $_ = <F>, 1 .. 4)[0] ) {
	my @r = map {chomp; $_} map $_ = <R>, 1 .. 4;
	@f = map {chomp; $_} @f;
	@r = map {chomp; $_} @r;
	my @i =	map { s/:/_/g; $_ }
		map { substr( $_, 1, index($_,' ')-1 ) } ($f[0], $r[0]);
	die ("Unmatched read IDs: @i!\n") if $i[0] ne $i[1];
	my (@fq,@rq,$fd,$rd);
	@fq = map {$_ - 33} unpack("C*", substr($f[3], 0, $c{$i[0]}[1]-1) );
	@rq = map {$_ - 33} unpack("C*", substr($r[3], 0, $c{$i[0]}[2] - $c{$i[0]}[0]-1) );
	
	@fq = grep {$_ < $opts{qual} } @fq;
	@rq = grep {$_ < $opts{qual} } @rq;
	
	
=begin
	#debug
	if((scalar @fq + scalar @rq)>0){
	say join("\n",$f[1],$r[1]);
	say substr($f[1], 0, $c{$i[0]}[1]-1);
	my $t = substr($r[1], 0, $c{$i[0]}[2] - $c{$i[0]}[0]-1);
	$t =~ tr/ATCG/TAGC/;
	say scalar reverse $t;
	
	say join(' ', scalar @fq, @fq);
	say join(' ', scalar @rq, @rq);
	
	say join("\n", @{ $c{$i[0]} });
	die;
	}
=cut
	
	map { ++$stat[0]{$_}; $fd=1 } @fq if scalar @fq + scalar @rq > $opts{maxpos};
	map { ++$stat[1]{$_}; $rd=1 } @rq if scalar @fq + scalar @rq > $opts{maxpos};
	
	#calculate statistics
	++$stat[2];		#all reads
	
	++$stat[7]{scalar @fq}[0];		#number of positions below threshold in R1
	++$stat[7]{scalar @rq}[1];		#number of positions below threshold in R2
	++$stat[7]{scalar @fq + scalar @rq}[2];	#number of positions below threshold in both R1 and R2
	
	if(defined($fd) && defined($rd)) {
		++$stat[5];	#discard due to both reads
	} elsif(defined($fd)) {
		++$stat[3];	#discard due to R1
	} elsif(defined($rd)) {
		++$stat[4];	#discard due to R2
	} else {
		++$stat[6];	#keep contig
		push @oc, $i[0] if $opts{write};
	}

}

if($opts{write}) {
	#print kept contigs in fasta format
	for(@oc) {
		say ">$_";
		say $c{$_}[3];
	}
} else {
	#print statistics
	my %out;
	map { $out{$_}[0] = $stat[0]{$_} } keys %{ $stat[0] };
	map { $out{$_}[1] = $stat[1]{$_} } keys %{ $stat[1] };

	say "==========================================================";
	printf("%-45s %5d\n",'Total number of reads:',$stat[2]);
	printf("%-45s %5d\n", 'Number of contigs to keep:', $stat[6]);
	printf("%-s\n", 'Contigs to be discarded due to');
	printf("   %-42s %5d\n",'both reads have bases below threshold:',$stat[5]);
	printf("   %-42s %5d\n",'R1 have bases below threshold:',$stat[3]);
	printf("   %-42s %5d\n",'R2 have bases below threshold:',$stat[4]);
	say "==========================================================";
	say "Phred-scores below threshold in R1 and R2";
	say "==========================================================";
	printf("%-2s %7s %7s\n", qw(Q R1 R2));
	for(sort {$a<=>$b} keys %out) {
		printf("%-2d %7d %7d\n", $_, $out{$_}[0] || -1, $out{$_}[1] || -1);
	}
	say "==========================================================";
	say "Number of Phred-scores below threshold in R1, R2 and both";
	say "==========================================================";
	my @t;
	for(sort {$a<=>$b} keys %{$stat[7]}) {
		if($_ >= 10){
			$t[10][0] += defined($stat[7]{$_}[0]) ? $stat[7]{$_}[0] : 0;
			$t[10][1] += defined($stat[7]{$_}[1]) ? $stat[7]{$_}[1] : 0;
			$t[10][2] += defined($stat[7]{$_}[2]) ? $stat[7]{$_}[2] : 0;
		} else {
			push @t, $stat[7]{$_};
		}
	}
	printf("%-3s %7s %7s %7s\n", qw(N R1 R2 Both));
	for(my $i=0; $i<=$#t; $i++) {
		
		printf("%-3s %7d %7d %7d\n",
			my $t = ($i == $#t) ? $i.'+' : $i,
			$t[$i][0] || -1,
			$t[$i][1] || -1,
			$t[$i][2] || -1
			);
	}
	say "==========================================================";
}
exit 0;
